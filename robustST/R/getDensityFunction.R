##' Get Density Functions
##' 
##' In order to fit different robust distributions, we need to use different
##' density and gradient of density functions.  This function contains the
##' function definitions for four classes of families:  N (normal), T
##' (Student's-t), SN (skew normal), ST (skew t).
##' 
##' This function returns a density function and the gradient of the density
##' function with respect to the parameters.  Both of these functions should
##' take three arguments: param, y, and k.  param should be the optimization
##' parameter, which is generated by setting dp to a list of the parameters
##' (i.e. xi, Omega, alpha, nu) and then calling sn:::dplist2optpar.  y is the
##' data, and k is the parameter controlling the robustness of the fit.
##' 
##' @param family The family to use, should be "N", "T", "SN" or "ST".
##' @param robust A logical value indicating whether the density and gradient
##' returned should correspond to the robust estimators or not.
##' 
##' @return A list of two functions, the first being the density function and
##' the second being the gradient of the density function.  To understand the
##' usage of this function, see ?robustSTOnceK.
##' 

## Test that this function works for all distributions

getDensityFunction = function(family, robust = TRUE){
    ## Data quality checks
    if(! family %in% c("N", "T", "SN", "ST"))
        stop("Invalid family provided.  Must be 'N', 'T', 'SN' or 'ST'")
    
    ## The distribution family influences the passed parameters.  A normal dist
    ## can be created by forcing symmetry and fixing nu to Inf, for example.
    if(family == "N"){
        defaultArgs = list(symmetr = TRUE, fixed.nu = Inf)
        paramAdj = function(param, d){
            c(param, rep(0, d), Inf)
        }
    } else if(family == "T"){
        defaultArgs = list(symmetr = TRUE)
        paramAdj = function(param, d){
            c(param[-length(param)], rep(0, d), param[length(param)])
        }
    } else if(family == "SN"){
        defaultArgs = list(fixed.nu = Inf)
        paramAdj = function(param, d){
            c(param, Inf)
        }
    } else if(family == "ST"){
        defaultArgs = list()
        paramAdj = function(param, d) param
    } else {
        stop("Current family not yet implemented")
    }
    
    if(robust){
        density = function(param, y, k){
            d = NCOL(y)
            param = paramAdj(param, d = d)
            args = c(defaultArgs, list(y = y, k = k, param = param))
            do.call("mst.pdev.robust", args = args)
        }
        gradient = function(param, y, k){
            d = NCOL(y)
            param = paramAdj(param, d = d)
            args = c(defaultArgs, list(y = y, k = k, param = param))
            do.call("mst.pdev.grad.robust", args = args)
        }
    } else {
        density = function(param, y, k){
            d = NCOL(y)
            param = paramAdj(param, d = d)
            args = c(defaultArgs, list(y = y, param = param))
            do.call("mst.pdev", args = args)
        }
        gradient = function(param, y, w = rep(1, NROW(y))){
            d = NCOL(y)
            param = paramAdj(param, d = d)
            args = c(defaultArgs, list(y = y, param = param))
            do.call("mst.pdev.grad", args = args)
        }
    }
    return(list(density = density, gradient = gradient))
}